#R相关默认的编码方式以及一些手动设置-----------------------------------------------

#编码类型	               函数	               适用场景
#虚拟编码（参照组对比）  contr.treatment()   无序因子（默认）
#效应编码（对比均值）	   contr.sum()	       实验设计（ANOVA）
#Helmert 编码	           contr.helmert()	   顺序对比（如时间点差异）
#正交多项式编码	         contr.poly()	       有序因子（默认）
#自定义编码	             手动矩阵	           特定研究需求

#变量类型	          推荐编码	      原因
#无序分类（如性别）	contr.treatment	直观对比各类与参照组的差异
#有序分类（如等级）	contr.poly	    检测线性/非线性趋势
#实验设计（ANOVA）	contr.sum	      各水平与整体均值对比
#时间序列	          contr.helmert	  相邻时间点差异分析


#分类变量在进行回归分析时，通常会进行一些编码设置--------------------------------------------

#最常见的是哑变量设置
#通常一个有K个类别的分类变量在进入回归分析时，
#会被自动编码成K-1个序列，
#然后会得到K-1个回归系数，
#这些回归系数对应着因变量根据K个类别分组后计算的平均值
#R中的这些编码方案又叫做比较（contrast）矩阵设计

#举例说明------------------------------------------------------------------------------------
#假设我们有一个因子型变量race，它有四个类别：1（西班牙裔）、2（亚洲人）、3（非裔美国人）、4（白人）。如果我们直接将其放入模型中
#模型会自动选择一个参考类别（通常是第一个类别，即1西班牙裔）
#然后为其他类别创建哑变量
#race2：表示是否是亚洲人（1表示是，0表示不是）。
#race3：表示是否是非裔美国人。
#race4：表示是否是白人。

#演示数据----------------------------------------------------------------------------------------
load(file = "C:\\Users\\Administrator\\Desktop\\R语言实战临床预测模型\\datasets\\codingSchemes.rdata")
# 把race变为因子型，并放到新的一列中
hsb2$race.f <- factor(hsb2$race, labels=c("Hispanic", "Asian", "African-Am", "Caucasian"))
# 根据race.f进行分组，计算分组后因变量write的均值
tapply(hsb2$write, hsb2$race.f, mean)
##   Hispanic      Asian African-Am  Caucasian 
##   46.45833   58.00000   48.20000   54.05517

#Dummy Coding哑变量虚拟编码（参照组对比）----------------------------------------------------------------------------------------------------------------------------
#哑变量是最常见的分类变量编码方式，它以其中一个类别为参考，
#其他所有类别都和参考进行比较
#contr.treatment()手动设置哑变量------------------------------------------------------------------
contr.treatment(4)
#如果有K个类别，就会有K-1个哑变量

#contrasts()查看不同变量编码方式------------------------------------------------
# 和上面的比较矩阵一模一样的形式
contrasts(hsb2$race.f)
#logistic回归时，多次使用过哑变量编码的方式，因为是默认的，所以并不用手动设置
#logistic回归手动设置和默认设置结果相同------------------------------------------------------------
# 手动定义变量的编码方式
contrasts(hsb2$race.f) <- contr.treatment(4)

# 进行回归
summary(lm(write ~ race.f, data = hsb2))

#结果中race.f2/race.f3/race.f4，都是和race.f1进行比较

#intercept（截距）的系数就是参考组write的平均值46.45833！也就是Hispanic组均值

#simple coding简单编码----------------------------------------------------------------------
#简单编码和哑变量编码的唯一不同之处是截距！
#哑变量的截距是参考组的因变量平均值，简单编码的截距是总的平均值。
#level 1还是参考组，对于race.f1，是类别2比类别1，类别2就被编码为3/4，其他类别都是 -1/4
#参考组肯定是被编码为 -1/4（和类别个数有关，这里race.f是4个类别），谁和参考组比谁就被编码为 3/4

#如果变量有K个类别的话，那就是参考组被编码为 -1/k，谁和参考组比谁就被编码为(k-1)/k
# 设置simple coding
c<-contr.treatment(4)
my.coding<-matrix(rep(1/4, 12), ncol=3)
my.simple<-c-my.coding
my.simple
# 把race.f变成simple coding
contrasts(hsb2$race.f) <- my.simple
# 进行回归
summary(lm(write ~ race.f, data = hsb2))
#除了截距不一样，其他的系数都是一样的
#截距51.6784 = (46.45833 + 58  + 48.2 + 54.05517)/4 

#Deviation coding效应编码（对比均值）------------------------------------------------------------------------------------------
#这种编码方式比较的是某个类别的因变量的均值和其他所有类别的因变量的均值
contr.sum(4)
##   [,1] [,2] [,3]
## 1    1    0    0
## 2    0    1    0
## 3    0    0    1
## 4   -1   -1   -1

#第1组中，类别1被设为1（因为是类别1和其他所有类别比较）
#第2组是类别2被设为1，第3组是类别3倍设为1
#而类别4一直是 -1，因为它没和别人比过

#把race.f这个变量设置为deviation coding再次进行回归分析
contrasts(hsb2$race.f) <- contr.sum(4)

summary(lm(write ~ race.f, data = hsb2))
#截距是总的均值，也就是(46.4583 + 58 + 48.2 + 54.0552) / 4 = 51.678375
#回归系数是相应类别的均值减去总的均值，
#比如race.f1的回归系数 -5.2200 = 46.4583 – 51.678375

#Orthogonal Polynomial Coding正交多项式编码--------------------------------------------------------------

#重复测量方差分析的多重比较中用过
#常用于线性趋势检验，检测某自变量的1次项、2次项、3次项等和因变量之间有无线性关系

# 新建一列，根据read转换为有序因子
hsb2$readcat <- cut(hsb2$read, 4, ordered=T)
table(hsb2$readcat)
tapply(hsb2$write, hsb2$readcat, mean)
contr.poly(4)
# 发现默认就是正交多项式编码
contrasts(hsb2$readcat)
#手动设置
contrasts(hsb2$readcat) <- contr.poly(4)

summary(lm(write ~ readcat, data = hsb2))


#有序变量回归系数解释------------------------------------------------------------------
#当有序变量（如教育程度：小学 < 中学 < 大学）被编码时
#contr.poly() 生成一组 正交对比系数

#一次项（.L）：检测变量是否存在线性趋势（如分数是否随等级单调递增/递减）（1次函数）
#二次项（.Q）：检测是否存在U型或倒U型趋势（如先升后降或先降后升）（2次函数）
#三次项（.C）：检测更复杂的非线性模式（如S型曲线）

#Helmert Coding------------------------------------------------------------------------------
#Helmert Coding比较的是当前类别下的因变量平均值和后面的类别的因变量平均值

my.helmert <- matrix(c(3/4, -1/4, -1/4, -1/4, 0, 2/3, -1/3, -1/3, 0, 0, 1/
                         2, -1/2), ncol = 3)
my.helmert
contrasts(hsb2$race.f) <- my.helmert

summary(lm(write ~ race.f, hsb2))
#结果是当前类别和后续的类别进行对比
#即race.f1 是1和234均值对比
#即race.f2 是2和34均值对比
#即race.f3 是3和4均值对比

#Reverse Helmert Coding--------------------------------------------------------------
#和Helmert Coding刚好完全相反，每一个类别和它前面的类别比较
contr.helmert(4)
#生成的矩阵是正交矩阵，和理论有点区别，但是含义一样都是每一个类别和它前面的类别比较
contrasts(hsb2$race.f) <- contr.helmert(4)

summary(lm(write ~ race.f, hsb2))


#Forward Difference Coding--------------------------------------------------------------------------
#比较当前类别的因变量均值和它相邻的下一个类别的因变量均值
my.forward.diff = matrix(c(3/4, -1/4, -1/4, -1/4, 1/2, 1/2, -1/2, -1/2, 1/
                             4, 1/4, 1/4, -3/4), ncol = 3)
my.forward.diff

contrasts(hsb2$race.f) <- my.forward.diff

summary(lm(write ~ race.f, data = hsb2))

#Backward Difference Coding----------------------------------------------------------------
my.backward.diff = matrix(c(-3/4, 1/4, 1/4, 1/4, -1/2, -1/2, 1/2, 1/2, -1/4, -1/4, -1/4, 3/4), ncol = 3)
my.backward.diff
contrasts(hsb2$race.f) <- my.backward.diff

summary(lm(write ~ race.f, data = hsb2))












